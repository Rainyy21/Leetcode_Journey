---
diffculty: easy
---
#easy 
Given a binary tree, determine if it is height balance.
****
**Umpire**
input: a array that symbolize a tree
output: boolean

idea: tree traversal, recursion

Thinking: what if we get the depth of the left and subtract from the depth of the right, if it greater than 1 than it not balance

plan: (wrong plan )
- we have a helper that take the root and recursion on itself
	- it not root return true
- we have a another helper node that give the dept of the node
	- it recourse down both right and left and give us the largest number
- we check if the height different from left and right is greater than one
	- return False if it is
- than we recursion from the left and right to see if both side are balance

```python
class solution(Object):
	def isBalance(self, root):
	def height(root):
		if not root:
			return 0
		return 1+ max(height(root.left), height(root.right))
	def checkHeight(root):
		if not root:
			return True
			
		Lhight = height(root.left)
		Rheight = height(root.right)

		if abs(Lheight - Rheight) > 1:
			return False
		return isBalanced(root.left) and isBalanced(root.right)
		
	checkHeight(root)
```

Improvement: 

```python
 def dfs(root):
            if not root:
                return 0
            ln=dfs(root.left)
            if ln==-1:
                return -1
            rn=dfs(root.right)
            if rn==-1:
                return -1
            
            if abs(ln-rn)>1:
                return -1

            return 1+max(ln,rn)
        return dfs(root)!=-1
```


****
**Example 1:**

![](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)

**Input:** root = [3,9,20,null,null,15,7]
**Output:** true

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)

**Input:** root = [1,2,2,3,3,null,null,4,4]
**Output:** false

**Example 3:**

**Input:** root = []
**Output:** true
