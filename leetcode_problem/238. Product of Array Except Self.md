---
diffculty: medium
---
#medium 
Given an integer array `nums`, return _an array_ `answer` _such that_ `answer[i]` _is equal to the product of all the elements of_ `nums` _except_ `nums[i]`.

The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.

You must write an algorithm that runs in `O(n)` time and without using the division operation.
****

**Umpire**
input: array of int
Output: return the product of the array but itself

Plan:
	what if we get the total amount product and the mount of zero
		if there are two zero than the entire product is zero 
		but if their one than only zero have a value
	we start the loop by first
		dividing the first value and adding it to the array and memory
	than we loop though the entire list
		we check if it in the memory if so replace the product and add it to the array
		else we just divide the current and multiple the previous to get the new product and add it to the memory
	we return the array at the end



```python
class Solution(object):
	def productExceptSelf(self, nums):
	"""
	:type nums: List[int]
	:rtype: List[int]
	"""
	
	array = []
	product = 1
	contZero = 0
	
	for i in nums:
		#this count the zero 
		if i == 0:
			contZero += 1
			continue
		product *= i
	
	# if there are any amount of zero there are two soultion
	if contZero > 0:
		# if more than one zero than the entire array is zero
		if contZero >1:
			for i in range(len(nums)):
				array.append(0)
			return array
		# if only one zero than the zero is the total product
		for i in range(len(nums)):
			if nums[i] == 0:
				array.append(product)
				continue
			array.append(0)
		return array
	
	#memory and intering the first value to the memory and array
	memo = {}
	
	product = product / nums[0]
	memo[nums[0]] = product
	array.append(product)
	
	  
	# we loop thoguh the rest of the array
	for i in range(1, len(nums)):
		# chceck it is memory to save time on the math 
		if nums[i] in memo:
			array.append(memo[nums[i]])
			product = memo[nums[i]]
			continue
		# we divde the current value and multiply it by the previous
		product = product / nums[i] *nums[i-1]
		#add it to the memory
		memo[nums[i]] = product
		array.append(product)
	
	
	return array
```

****
**Example 1:**

**Input:** nums = [1,2,3,4]
**Output:** [24,12,8,6]

**Example 2:**

**Input:** nums = [-1,1,0,-3,3]
**Output:** [0,0,9,0,0]